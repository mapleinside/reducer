# Reducer

> Helper that enhance Redux reducer capacities

> ❌ Sorry, but this library is no longer maintained. Please find an alternative.

One of the strength of the Redux pattern is its reducer part.

But it is a problem when projects become bigger and the amount of code that can be shared between actions and reducers can be huge.

That's why this module exists. It provides an easy to use API to create actions and reducers. It also provides a default behavior for some use cases that can drastically reduce the amount of code in reducers. See [Asynchronous actions](#asynchronous-actions).

This walk-through is about how to use the reducer module. It assumes you know how to use the Redux pattern and how it works.

## Create a reducer

As an example lets create a reducer that will handle the data of a specific user. It requires only 3 lines of code.

```javascript
// redux/reducers/User.js

import Reducer from '@nicolascava/reducer';

const reducer = new Reducer();

export default reducer.bindReducer();
```

The way you bind this newly created reducer to the Redux store is the same as usual. Using this method to create a reducer does not affect anything outside of it.

```javascript
// redux/Reducer.js

import { combineReducers } from 'redux';

import User from './reducers/User';

export default combineReducers({ user: User });
```

## Initial state

By default, the initial state of the reducer is an empty object. But **you should always** explicitly set the initial state, even if it is empty.

To specify an initial state to the reducer, just pass it as the **first** argument to the constructor.

```javascript
// redux/Reducer.js

const initialState = {
  type: 'admin',
};

const reducer = new Reducer(initialState);
```

## Synchronous actions

In order to make a reducer interact with the data, we need an action.

Let's say we want to change the type of a user in local (for interaction with a server, see [Asynchronous actions](#asynchronous-actions)).

```javascript
// redux/reducers/User.js`

const SET_TYPE = `${appName}/user/SET_TYPE`;

export const setType = Reducer.createAction(SET_TYPE);
```

The way you tell the reducer to react to the actions is slightly different from the original version of Redux. 

Instead of using a switch statement, the module uses functions. Each case the reducer should handle must be in an object. Keys are representing the action and their values should be in the form of a function. 

These functions receive the current state and the action and must return a new object representing the new state, after mutation (just like in the original Redux model).

To tell the reducer to react to these cases, simply pass the object as a **second** argument to the constructor.

```javascript
// redux/reducers/User.js`

const cases = {
  [SET_TYPE]: (state, { payload }) => ({
    ...state,
    type: payload.type,
  })
};
const reducer = new Reducer(initialState, cases);
```

## Asynchronous actions

Asynchronous actions work almost the same as synchronous ones. 

Except that you need to pass it a Promise and an action type for the base action (the `Success` and `Failure` types are predictably generated by the module, enforcing a certain coding standard).

Let's say we need an action to update the user on the server.

```javascript
// redux/reducers/User.js`

const UPDATE = `${appName}/user/UPDATE`;

export const update = reducer.createAsyncAction(
  UPDATE,
  (client, data) => client.patch(`/users/${data.id}`, data),
);
```

Now the reducer needs to listen to the actions.

But wait, we did not declare any `Success` or `Failure` action?! That's right, the module takes care of this part by predictably generating them. It creates the actions of `Success` and `Failure` by appending `_SUCCESS` or `_FAILURE` to the base action. 

So, to make the reducer reacts to these: 

```javascript
// redux/reducers/User.js`

const UPDATE = `${appName}/user/UPDATE`;
const cases = {
  [UPDATE]: state => ({
    ...state,
    updating: true,
    updated: false,
    updateFailed: false,
  }),
  [`${UPDATE}_SUCCESS`]: (state, payload) => ({
    ...state,
    updating: false,
    updated: true,
    updateFailed: false,
    payload,
  }),
  [`${UPDATE}_FAILURE`]: (state, error) => ({
    ...state,
    updating: false,
    updated: false,
    updateFailed: true,
    error,
  }),
};
const reducer = new Reducer(initialState, cases);
```

That's it, the reducer now understands and reacts to async actions.

I say that this is going to help reducing boilerplate, but it does not seem to help that much.

True! That's why the example above is handled **directly by the module**. 

You don't need all that code as these cases are generated by the module, out of the box. The only thing you need to do is to add a third argument to `createAsyncAction` being an `array` containing the keys of the states reflecting the current state of the action.

Knowing this, the complete code to handle an async case **with the behavior described above** looks like this:

```javascript
// redux/reducers/User.js

const UPDATE = `${appName}/user/UPDATE`;
const reducer = new Reducer(initialState, cases);

export const update = reducer.createAsyncAction(
  UPDATE,
  (client, data) => client.patch(`/users/${data.id}`, data),
  ['updating', 'updated', 'updateFailed'],
);
```

Way shorter, isn't it?

Well, that said, sometimes, in case of a `Success` or a `Failure` you will need special treatments that the module can not guess by itself. That's why you can easily override these cases!

### Override a generated reducer case

As said, sometimes the default behavior does not match the needs.

In that case, just add the case to override inside the object passed to the constructor. Let's say we want to set a state containing a message when the user is updated:

```javascript
// redux/reducers/User.js`

const cases = {
  [`${UPDATE}_SUCCESS`]: (state, payload) => ({
    ...state,
    updating: false,
    updated: true,
    updateFailed: false,
    payload,
    message: 'User updated!',
  }),
};
const reducer = new Reducer(initialState, cases);
```

Still worth it? Absolutely. You added one case instead of three! With this module, reducers are loosing some extra weight!

## License

The MIT License (MIT)

Copyright (c) 2020 Nicolas Cava

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
